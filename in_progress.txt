It is possible to take a step that has one change you want, and one you do not want, then find a step to reverse the
unwanted change.

testing: required_change /bit2:1->0/bit1:0->1 step chg: /bit3:1->0/bit2:1->0 unneeded chg: /bit3:1->0
testing: rev steps found: [[r00XX0XXX -03> r00XX1XXX], [r00XX0XXX -06> r00XX1XXX]]
testing: adding stepstore [[r00111101 -06> r00110001], [r00110001 -03> r00111001]]
testing: adding stepstore [[r00111001 -01> r00111011]]
forward chaining test worked! [[r00111101 -06> r00110001], [r00110001 -03> r00111001], [r00111001 -01> r00111011]]

    /// Return a plan from random depth-first forward chaining to goal.
    fn random_depth_first_forward_chaining_test(&self, from_reg: &SomeRegion, goal_reg: &SomeRegion, steps_str: &StepStore) -> Option<StepStore> {

        let required_change = SomeChange::region_to_region(from_reg, goal_reg);

        let mut steps_rev2 = Vec::<StepStore>::with_capacity(steps_str.len());

        let care_chg_mask = goal_reg.x_mask().m_not();

        for stpy in steps_str.iter() {

            if stpy.initial.intersects(from_reg) {
            } else {
                continue;
            }

            // Restrict step to non-X bits in the from region
            let stpx = stpy.restrict_initial_region(from_reg);
            
            let chg_not = &required_change.change_not();
            let chg_dif = stpx.rule.change().change_and(&chg_not).change_and_mask(&care_chg_mask);
            
            if chg_dif.is_low() {
                let mut stpstr = StepStore::new_with_capacity(1);
                stpstr.push(stpx.clone());
                println!("testing: adding stepstore {}", &stpstr);
                steps_rev2.push(stpstr);
            } else {
                let chg_rev = chg_dif.change_reverse();
                println!("testing: required_change {} step chg: {} unneeded chg: {}", &required_change, stpx.rule.change(), &chg_dif);

                let steps_rev : StepStore = self.actions.get_steps(&chg_rev);
                println!("testing: rev steps found: {}", &steps_rev);
                for stp_revx in steps_rev.iter() {
                    if stp_revx.initial.intersects(&stpx.result) {
                        
                        let stp_revx2 = stp_revx.restrict_initial_region(&stpx.result);
                        if stp_revx2.rule.change() == chg_rev {
                            let mut stpstr = StepStore::new_with_capacity(2);
                            stpstr.push(stpx.restrict_result_region(&stp_revx2.initial));
                            stpstr.push(stp_revx2);
                            println!("testing: adding stepstore {}", &stpstr);
                            steps_rev2.push(stpstr);
                        }
                    }
                }
            } //end if
        }

        if steps_rev2.len() == 0 {
            return None;
        }

       // Get stepstores that have a result region that intersects the goal region
        let mut next_steps = Vec::<usize>::new();
        let mut inx = 0;
        for stpstrx in &steps_rev2 {
            if stpstrx.result().intersects(goal_reg) {
                next_steps.push(inx);
            }
            inx += 1;
        }

        // Randomly pick a solution stepstore
        if next_steps.len() > 0 {
            let mut step_inx_inx = 0;
            if next_steps.len() > 1 {
                step_inx_inx = rand::thread_rng().gen_range(0, next_steps.len());
            }
            let step_inx = next_steps[step_inx_inx];
            return Some(steps_rev2[step_inx].clone());
        }

        // Randomly pick a step index from the options.

        let step_inx = rand::thread_rng().gen_range(0, steps_rev2.len());

        // Calculate the next state from the step
        let next_reg = steps_rev2[step_inx].result();

        // Use recursion to get next steps
        if let Some(more_steps) = self.random_depth_first_forward_chaining_test(&next_reg, goal_reg, steps_str) {

            if let Some(ret_steps2) = steps_rev2[step_inx].link(&more_steps) {
                return Some(ret_steps2);
            }
        }

        None
    } // end random_depth_first_forward_chaining_test

