;;; Implement a data store for a session.

(defstruct sessiondata
    domains         ; A DomainStore intstance of one, or more, domains.
    needs           ; A NeedStore of needs generated by domains.
    can-do          ; A NeedStore of needs that can be done.
    cant-do         ; A NeedStore of needs that cannot be done.
    selectregions-store ; A SelectRegionsStore.
    selectregions-paths   ; Non-rated selectregions plus selectregion split by intersections.
    le0-levels       ; A list of successively more negative selectregion levels, starting with 0.
)
; Functions automatically created by defstruct:
;
; Most used:
;   (sessiondata-<field name> <instance>) -> struct field.
;   (sessiondata-p <instance>) -> bool
;
; Least used:
;   (type-of <instance>) -> sessiondata
;   (typep <instance> 'sessiondata) -> bool
;
; Probably shouldn't use:
;   (make-sessiondata [:<field-name> <field-sessiondata>]*), use sessiondata-new instead.
;   (copy-sessiondata <instance>) copies a sessiondata instance.

(defun sessiondata-new () ; -> sessiondata
    (make-sessiondata :domains (domainstore-new)
                      :needs (needstore-new nil)
                      :can-do (needstore-new nil)
                      :cant-do (needstore-new nil)
                      :selectregions-store (selectregionstore-new nil)
                      :le0-levels nil
    )
)

;;; Return a string representation of a sessiondata instance.
(defun sessiondata-str (sessx)  ; -> string.                                                                      
  (assert (sessiondata-p sessx))

    (let ((strs "#S(SESSIONDATA "))
      (setf strs (concatenate 'string strs (domainstore-str (sessiondata-domains sessx))))

      (setf strs (concatenate 'string strs ")"))

      strs
    )
) 

;;; Print sessiondata.
(defun sessiondata-print (sessx)
  (assert (sessiondata-p sessx))

  (let ((rate -20))
    (setf rate (selectregionsstore-rate (sessiondata-selectregions-store sessx) (sessiondata-domain-current-regions sessx)))
    (format t "~&Current states: ~A Status: ~A ~A" (statescorr-str (sessiondata-domain-current-states sessx))
       (rate-effect rate) (rate-str rate))

    (domainstore-print (sessiondata-domains sessx))
  )
)

;;; Return a sessiondata instance, given a list of symbols.
(defun sessiondata-from (symbols) ; -> sessiondata instance.
    ;(format t "~&sessiondata-from: ~A" (type-of symbols))
    (assert (listp symbols))
    (assert (not (null symbols)))
    (assert (typep (car symbols) 'SYMBOL))
    (assert (eq (car symbols) 'SD))
    
    (let (sdx key ds sr sc rest-symbols)
        (cond ((string= (symbol-name (car symbols)) "SD")
                (setf rest-symbols (cdr symbols))
                ;(format t "~&sessiondata-from4 ~A ~A" (type-of rest-symbols) rest-symbols)

                ; Process tokens, get domainstore.
                (loop for tokx in rest-symbols do
                    (setf key (symbol-name (car tokx)))
                    ;(format t "~&sessiondata-from: tokx: ~A" tokx)
                    (when (string= key "DS") ; Must be just one domainstore.
                           ;(format t "~&sessiondata-from: ds: ~A" tokx)
                           (assert (null ds)) ; only one ds allowed.
                           (setf ds (domainstore-from tokx))
                           (if (null ds)
                             (error "~&sessiondata-from: ds: ~A failed" tokx))
                     )
                )
                (assert ds) ; one ds required.

                ;; Start sessiondata.
                (setf sdx (make-sessiondata :domains ds
                                            :needs (needstore-new nil)
                                            :can-do (needstore-new nil)
                                            :cant-do (needstore-new nil)
                                            :selectregions-store (selectregionsstore-new nil)
                                            :selectregions-paths (selectregionsstore-new nil)))

                ;(sessiondata-print sdx)

                ;; Get select regions and statescorr, if any.
                (loop for tokx in rest-symbols do
                    ;(format t "~&sessiondata-from: tokx2: ~A" tokx)
                    (setf key (symbol-name (car tokx)))
                    (cond ((string-equal key "DS") nil) ; Skip ds.
                          ((string= key "SR") ; Can be zero, or more, selectregions.
                           ;(format t "~&sessiondata-from: sr: ~A" tokx)
                           (setf sr (selectregions-from tokx))
                           (if sr
                             (selectregionsstore-push (sessiondata-selectregions-store sdx) sr)
                             (error "~&sessiondata-from: sr: ~A failed" tokx))
                          )
                          ((string= key "SC") ; Must be zero, or one, statescorr.
                           ;(format t "~&sessiondata-from: sc: ~A" tokx)
                           (setf sc (statescorr-from tokx))
                           (if sc
                             (domainstore-set-states (sessiondata-domains sdx) sc)
                             (error "~&sessiondata-from: sc: ~A failed" tokx))
                          )
                      (t (error "~&token not recognized: ~A" tokx))
                    )
                )

                (sessiondata-process-select-regions sdx)

                ;; Return sessiondata instance.
                (return-from sessiondata-from sdx)
              )
              (t (error "SD symbol missing")))
     )
     (error "drop-through?")
)

;;; Process selectregions, display results.
(defun sessiondata-process-select-regions (sdx) ; -> side-effect, load selectregions-paths and le0-levels.
  (assert (sessiondata-p sdx))

  (let (path-regions (nums (list 0)))
    ;; Calc rate (0, 0) selectregions.
    (setf path-regions (regionscorrstore-new (list (sessiondata-domain-max-regions sdx))))
    (loop for srx in (selectregionsstore-selectregions (sessiondata-selectregions-store sdx)) do
      (setf path-regions (regionscorrstore-subtract-regionscorr path-regions (selectregions-regionscorr srx)))
    )
    ;; Add selectregions split by intersections.
    (setf path-regions (regionscorrstore-append path-regions
          (regionscorrstore-split-by-intersections (selectregionsstore-regionscorrstore (sessiondata-selectregions-store sdx)))))
                
    ;; Add to sessiondata-selectregions-paths.
    (loop for rcx in (regionscorrstore-regionscorrs path-regions) do
      (selectregionsstore-push (sessiondata-selectregions-paths sdx)
        (selectregions-new rcx (selectregionsstore-rate (sessiondata-selectregions-store sdx) rcx)))
    )

    (format t "~& ~&Selectregions:")
    (loop for selx in (selectregionsstore-selectregions (sessiondata-selectregions-store sdx)) do
      (format t "~&    ~A" (selectregions-str selx))
    )
    (format t "~& ~&Paths:" (selectregionsstore-str (sessiondata-selectregions-paths sdx)))
    (loop for selx in (selectregionsstore-selectregions (sessiondata-selectregions-paths sdx)) do
      (format t "~&    ~A" (selectregions-str selx))
    )
    ;; Create list of negative levels. 
    (loop for selx in (selectregionsstore-selectregions (sessiondata-selectregions-store sdx)) do
      (if (not (member (rate-negative (selectregions-rate selx)) nums))
        (push (rate-negative (selectregions-rate selx)) nums))
      )
    (setf (sessiondata-le0-levels sdx) (sort nums #'>))
    (format t "~& ~&LE0-levels: ~A" (sessiondata-le0-levels sdx))
  )
)

;;; Return all domain current states.
(defun sessiondata-domain-current-states (sessx) ; -> StatesCorr
  (domainstore-all-current-states (sessiondata-domains sessx))
)

;;; Return all domain current states as regions.
(defun sessiondata-domain-current-regions (sessx) ; -> RegionsCorr
  (let ((ret (regionscorr-new nil)))
    (loop for stax in (statescorr-state-list (domainstore-all-current-states (sessiondata-domains sessx))) do
      (regionscorr-add-end ret (region-new stax)) 
    )
    ret
  )
)

;;; Return all domain maximum regions.
(defun sessiondata-domain-max-regions (sessx) ; -> RegionsCorr
  (domainstore-max-regions (sessiondata-domains sessx))
)

;;; Return current needs.
(defun sessiondata-get-needs (sessx) ; -> (values can-do cant-do)
  ;(format t "~&sessiondata-get-needs ~A" (type-of sessx))
  (assert (sessiondata-p sessx))

  (multiple-value-bind (needs can-do cant-do)
      (domainstore-get-needs (sessiondata-domains sessx))
      (setf (sessiondata-needs sessx) needs)
      (setf (sessiondata-can-do sessx) can-do)
      (setf (sessiondata-cant-do sessx) cant-do)
  )
)

;;; Process a given need.
(defun sessiondata-process-need (sessx nedx)
  ;(format t "~&sessiondata-process-need: ~A ~A" (type-of sessx) (type-of nedx))
  (assert (sessiondata-p sessx))
  (assert (need-p nedx))

  (domainstore-process-need (sessiondata-domains sessx) nedx)
)

;;; Return the number of domains.
(defun sessiondata-num-domains (sessx) ; -> integer
  (assert (sessiondata-p sessx))

  (domainstore-length (sessiondata-domains sessx))
)

;;; Return the number of actions for a given domain.
(defun sessiondata-num-actions (sessx dom-id) ; -> integer
  (assert (sessiondata-p sessx))
  (assert (and (integerp dom-id) (< dom-id (sessiondata-num-domains sessx))))
 
  (actionstore-length (domain-actions (domainstore-nth (sessiondata-domains sessx) dom-id)))
)

;;; Tak a domain action for need.
(defun sessiondata-take-action-need (sessx dom-id act-id statex)
  (assert (sessiondata-p sessx))
  (assert (integerp dom-id))
  (assert (< dom-id (sessiondata-num-domains sessx)))
  (assert (and (integerp act-id) (< act-id (sessiondata-num-actions sessx dom-id))))

  (action-take-sample-for-need (actionstore-nth (domain-actions (domainstore-nth (sessiondata-domains sessx) dom-id)) act-id) statex)
)

(defun sessiondata-find-square (sessx dom-id act-id statex) ; -> square, or nil.
  (assert (sessiondata-p sessx))
  (assert (and (integerp dom-id) (< dom-id (sessiondata-num-domains sessx))))
  (assert (and (integerp act-id) (< act-id (sessiondata-num-actions sessx dom-id))))

  (action-find-square (actionstore-nth (domain-actions (domainstore-nth (sessiondata-domains sessx) dom-id)) act-id) statex)
)

(defun sessionstore-get-plans (sessx to-regs) ; -> PlansCorrStore.
  (assert (sessiondata-p sessx))
  (assert (regionscorr-p to-regs))

  (domainstore-get-plans (sessiondata-domains sessx) (domainstore-all-current-regions (sessiondata-domains sessx)) to-regs)
 
)
