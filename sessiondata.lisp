;;; Implement a data store for a session.

(defstruct sessiondata
    domains         ; A DomainStore intstance of one, or more, domains.
    needs           ; A NeedStore of needs generated by domains.
    can-do          ; A NeedStore of needs that can be done.
    cant-do         ; A NeedStore of needs that cannot be done.
    selectregions-store ; A SelectRegionsStore.
    selectregions-fragments   ; Selectregions-store split by intersections.
    le0-levels       ; A list of successively more negative selectregion levels, starting with 0.
    regionscorrstore-paths ; List of regioncorrstores, for each le0-level.
    cycle-num        ; Current cycle number.
    num-cycles-at    ; Number cycles at the current position.  Used with positive selectregions.
                    ; Stay in a positive selectregion for a number of cycles up to the value of the selectregion,
                    ; if there is another positive selectregion option, else stay in one region.
    previous-position ; Previous cycle position.
)
; Functions automatically created by defstruct:
;
; Most used:
;   (sessiondata-<field name> <instance>) -> struct field.
;   (sessiondata-p <instance>) -> bool
;
; Least used:
;   (type-of <instance>) -> sessiondata
;   (typep <instance> 'sessiondata) -> bool
;
; Probably shouldn't use:
;   (make-sessiondata [:<field-name> <field-sessiondata>]*), use sessiondata-new instead.
;   (copy-sessiondata <instance>) copies a sessiondata instance.

(defun sessiondata-new () ; -> sessiondata
    (make-sessiondata :domains (domainstore-new)
                      :needs (needstore-new nil)
                      :can-do (needstore-new nil)
                      :cant-do (needstore-new nil)
                      :selectregions-store (selectregionstore-new nil)
                      :selectregions-fragments (selectregionstore-new nil)
                      :le0-levels nil
                      :regionscorrstore-paths nil
                      :cycle-num 0
                      :num-cycles-at 0
                      :previous-position (statescorr-new nil)
    )
)

;;; Increment the cycle num.
(defun sessiondata-inc-cycle-num (sessx) ; -> side effect, cycle num changed.
  (setf (sessiondata-cycle-num sessx) (+ 1 (sessiondata-cycle-num sessx)))
)

;;; Return a string representation of a sessiondata instance.
(defun sessiondata-str (sessx)  ; -> string.                                                                      
  (assert (sessiondata-p sessx))

    (let ((strs "#S(SESSIONDATA "))
      (setf strs (concatenate 'string strs (domainstore-str (sessiondata-domains sessx))))

      (setf strs (concatenate 'string strs ")"))

      strs
    )
) 

;;; Print sessiondata.
(defun sessiondata-print (sessx)
  (assert (sessiondata-p sessx))

  (let ((rate -20))
    (setf rate (selectregionsstore-rate (sessiondata-selectregions-store sessx) (sessiondata-domain-current-regions sessx)))
    (format t "~&Current states: ~A Status: ~A ~A" (statescorr-str (sessiondata-domain-current-states sessx))
       (rate-effect rate) (rate-str rate))
    (if (plusp (sessiondata-num-cycles-at sessx))
      (format t ", boredom/satiation counter ~D" (sessiondata-num-cycles-at sessx)))

    (domainstore-print (sessiondata-domains sessx))
  )
)

;;; Return a sessiondata instance, given a list of symbols.
(defun sessiondata-from (symbols) ; -> sessiondata instance.
    ;(format t "~&sessiondata-from: ~A" (type-of symbols))
    (assert (listp symbols))
    (assert (not (null symbols)))
    (assert (typep (car symbols) 'SYMBOL))
    (assert (eq (car symbols) 'SD))
    
    (let (sdx key ds sr sc rest-symbols)
        (cond ((string= (symbol-name (car symbols)) "SD")
                (setf rest-symbols (cdr symbols))
                ;(format t "~&sessiondata-from4 ~A ~A" (type-of rest-symbols) rest-symbols)

                ; Process tokens, get domainstore.
                (loop for tokx in rest-symbols do
                    (setf key (symbol-name (car tokx)))
                    ;(format t "~&sessiondata-from: tokx: ~A" tokx)
                    (when (string= key "DS") ; Must be just one domainstore.
                           ;(format t "~&sessiondata-from: ds: ~A" tokx)
                           (assert (null ds)) ; only one ds allowed.
                           (setf ds (domainstore-from tokx))
                           (if (null ds)
                             (error "~&sessiondata-from: ds: ~A failed" tokx))
                     )
                )
                (assert ds) ; one ds required.

                ;; Start sessiondata.
                (setf sdx (make-sessiondata :domains ds
                                            :needs (needstore-new nil)
                                            :can-do (needstore-new nil)
                                            :cant-do (needstore-new nil)
                                            :selectregions-store (selectregionsstore-new nil)
                                            :selectregions-fragments (selectregionsstore-new nil)
                                            :le0-levels nil
                                            :regionscorrstore-paths nil
                                            :cycle-num 0
                                            :num-cycles-at 0
                                            :previous-position (domainstore-all-current-states ds)))

                ;(sessiondata-print sdx)

                ;; Get select regions and statescorr, if any.
                (loop for tokx in rest-symbols do
                    ;(format t "~&sessiondata-from: tokx2: ~A" tokx)
                    (setf key (symbol-name (car tokx)))
                    (cond ((string-equal key "DS") nil) ; Skip ds.
                          ((string= key "SR") ; Can be zero, or more, selectregions.
                           ;(format t "~&sessiondata-from: sr: ~A" tokx)
                           (setf sr (selectregions-from tokx))
                           (if sr
                             (selectregionsstore-push (sessiondata-selectregions-store sdx) sr)
                             (error "~&sessiondata-from: sr: ~A failed" tokx))
                          )
                          ((string= key "SC") ; Must be zero, or one, statescorr.
                           ;(format t "~&sessiondata-from: sc: ~A" tokx)
                           (setf sc (statescorr-from tokx))
                           (if sc
                             (domainstore-set-states (sessiondata-domains sdx) sc)
                             (error "~&sessiondata-from: sc: ~A failed" tokx))
                          )
                      (t (error "~&token not recognized: ~A" tokx))
                    )
                )

                (sessiondata-process-select-regions sdx)

                ;; Return sessiondata instance.
                (return-from sessiondata-from sdx)
              )
              (t (error "SD symbol missing")))
     )
     (error "drop-through?")
)

;;; Process selectregions, display results.
(defun sessiondata-process-select-regions (sdx) ; -> side-effect, load selectregions-fragments, le0-levels, regionscorrstore-paths.
  (assert (sessiondata-p sdx))

  ;; Check for no selectregions.
  (if (selectregionsstore-is-empty (sessiondata-selectregions-store sdx))
    (return-from sessiondata-process-select-regions))

  ;; Print selectregions
  (format t "~& ~&Selectregions:")
  (loop for selx in (selectregionsstore-selectregions (sessiondata-selectregions-store sdx)) do
    (format t "~&    ~A" (selectregions-str selx))
  )

  (let (fragments nums paths max-regs nrate next-paths)

    ;; Calc and save fragments as selectregions.
    (setf fragments
          (regionscorrstore-split-by-intersections (selectregionsstore-regionscorrs (sessiondata-selectregions-store sdx))))
    
    (loop for rcx in (regionscorrstore-regionscorrs fragments) do
      (selectregionsstore-push (sessiondata-selectregions-fragments sdx)
         (selectregions-new rcx (selectregionsstore-rate (sessiondata-selectregions-store sdx) rcx)))
    )
                
    ;; Print fragments.
    (format t "~& ~&Fragments:")
    (loop for selx in (selectregionsstore-selectregions (sessiondata-selectregions-fragments sdx)) do
      (format t "~&    ~A" (selectregions-str selx))
    )

    ;; Create, sort and save a list of negative levels. 
    (loop for selx in (selectregionsstore-selectregions (sessiondata-selectregions-store sdx)) do
      (if (not (member (rate-negative (selectregions-rate selx)) nums))
        (push (rate-negative (selectregions-rate selx)) nums))
    )
    (setf nums (sort nums #'>))
    (setf (sessiondata-le0-levels sdx) nums)

    ;; Print LE0 levels.
    (format t "~& ~&LE0-levels: ~A" nums)

    ;; Calc regionscorr paths for each le0 level.
    (setf paths nil)
    (setf max-regs (sessiondata-domain-max-regions sdx))
    (push (regionscorrstore-new (list max-regs)) paths)

    (when (> (length nums) 1)
      (loop for levx in (reverse (butlast nums)) do  ; The last value will be associated with max-regions.
        ;(format t "~&  levx ~D" levx)
        (setf next-paths (regionscorrstore-new (list max-regs)))

        (loop for selx in  (selectregionsstore-selectregions (sessiondata-selectregions-fragments sdx)) do    
          (setf nrate (rate-negative (selectregions-rate selx)))
          (when (not (zerop nrate))
            (if (< nrate levx)
              (setf next-paths (regionscorrstore-subtract-regionscorr next-paths (selectregions-regionscorr selx))))
          )
        )
        (push next-paths paths)
      )
    )

    ;; Print and save paths.
    (format t "~& ~&Levels and paths:")
    (loop for rcsx in paths
          for levx in (sessiondata-le0-levels sdx) do
      (format t "~&   ~d ~a" levx (regionscorrstore-str rcsx))
    )
    (setf (sessiondata-regionscorrstore-paths sdx) paths)
  )
)

;;; Return all domain current states.
(defun sessiondata-domain-current-states (sessx) ; -> StatesCorr
  (domainstore-all-current-states (sessiondata-domains sessx))
)

;;; Return all domain current states as regions.
(defun sessiondata-domain-current-regions (sessx) ; -> RegionsCorr
  (let ((ret (regionscorr-new nil)))
    (loop for stax in (statescorr-state-list (domainstore-all-current-states (sessiondata-domains sessx))) do
      (regionscorr-add-end ret (region-new stax)) 
    )
    ret
  )
)

;;; Return all domain maximum regions.
(defun sessiondata-domain-max-regions (sessx) ; -> RegionsCorr
  (domainstore-max-regions (sessiondata-domains sessx))
)

;;; Return current needs.
(defun sessiondata-get-needs (sessx) ; -> (values can-do cant-do)
  ;(format t "~&sessiondata-get-needs ~A" (type-of sessx))
  (assert (sessiondata-p sessx))

  (multiple-value-bind (needs can-do cant-do)
      (domainstore-get-needs (sessiondata-domains sessx))
      (setf (sessiondata-needs sessx) needs)
      (setf (sessiondata-can-do sessx) can-do)
      (setf (sessiondata-cant-do sessx) cant-do)
  )

  ;; Get domain needs while avoiding negative selectregions.
  (let ((dmxs (sessiondata-domains sessx)))

    (loop for nedx in (needstore-need-list (sessiondata-can-do sessx)) do

      (when (plan-is-not-empty (need-plan nedx)) 
      
        (let (targetx)
 
          (if (state-p (need-target nedx))
            (setf targetx (region-new (list (need-target nedx))))
            (setf targetx (need-target nedx)))
 
          (let (new-target plans)
  
            ;; Calc all-domains target.
            (setf new-target (regionscorr-new nil))
            (loop for domx in (domainstore-domains dmxs) do
              (if (= (domain-id domx) (need-dom-id nedx))
                (regionscorr-add-end new-target targetx)
                (regionscorr-add-end new-target (domain-max-region domx))
              )
            ) ; next domx
 
            ;; Get plans
            (setf plans (sessiondata-get-plans sessx new-target))
 
            (when (not (null plans))
              ;(format t "~&planxx: ~A vs ~A" (plan-str (need-plan nedx)) (planscorrstore-str plans))
              (setf (need-plan nedx) plans)
            )
          ) ; end let
        ) ; end let
      ) ; end when
    ) ; next nedx
  )

  ;; If no domain needs can be done, check status of current states.
  (when (needstore-is-empty (sessiondata-can-do sessx))

    (let (needs (neg-needs-can-do 0))

      ;; Get needs for moving out of a negative selectregions, if any.
      (setf needs (sessiondata-move-from-negative-selectregions sessx))

      (when (needstore-is-not-empty needs)

        (loop for nedx in (needstore-needs needs) do
  
          (if (need-plan nedx)
            (progn
              (incf neg-needs-can-do)
              (needstore-push (sessiondata-can-do sessx) nedx)
            )
            (needstore-push (sessiondata-cant-do sessx) nedx)
          )
          (needstore-push (sessiondata-needs sessx) nedx)
        ) ; next nedx
        (if (> neg-needs-can-do 0)
          (return-from sessiondata-get-needs) 
        )
      ) ; end when

      ;; Get need for moving to a positive selectregions, if any.
      (setf needs (sessiondata-move-to-positive-selectregions sessx))
      (when (needstore-is-not-empty needs)
        (loop for nedx in (needstore-needs needs) do
  
          (if (need-plan nedx)
            (needstore-push (sessiondata-can-do sessx) nedx)
            (needstore-push (sessiondata-cant-do sessx) nedx)
          )
          (needstore-push (sessiondata-needs sessx) nedx)
        ) ; next nedx
      )
    ) ; end let
  ) ; end when

) ; end sessiondata-get-needs

;;; Process a given need.
;;; TODO pass (sessiondata-selectregions-paths sessx) to domainstore-process-need.
(defun sessiondata-process-need (sessx nedx)
  ;(format t "~&sessiondata-process-need: ~A ~A" (type-of sessx) (type-of nedx))
  (assert (sessiondata-p sessx))
  (assert (need-p nedx))

  (domainstore-process-need (sessiondata-domains sessx) nedx)
)

;;; Return the number of domains.
(defun sessiondata-num-domains (sessx) ; -> integer
  (assert (sessiondata-p sessx))

  (domainstore-length (sessiondata-domains sessx))
)

;;; Return the number of actions for a given domain.
(defun sessiondata-num-actions (sessx dom-id) ; -> integer
  (assert (sessiondata-p sessx))
  (assert (and (integerp dom-id) (< dom-id (sessiondata-num-domains sessx))))
 
  (actionstore-length (domain-actions (domainstore-nth (sessiondata-domains sessx) dom-id)))
)

;;; Take a domain action for need.
(defun sessiondata-take-action-need (sessx dom-id act-id statex)
  (assert (sessiondata-p sessx))
  (assert (integerp dom-id))
  (assert (< dom-id (sessiondata-num-domains sessx)))
  (assert (and (integerp act-id) (< act-id (sessiondata-num-actions sessx dom-id))))

  (action-take-sample-for-need (actionstore-nth (domain-actions (domainstore-nth (sessiondata-domains sessx) dom-id)) act-id) statex)
)

;;; Find a square, given a state.
(defun sessiondata-find-square (sessx dom-id act-id statex) ; -> square, or nil.
  (assert (sessiondata-p sessx))
  (assert (and (integerp dom-id) (< dom-id (sessiondata-num-domains sessx))))
  (assert (and (integerp act-id) (< act-id (sessiondata-num-actions sessx dom-id))))

  (action-find-square (actionstore-nth (domain-actions (domainstore-nth (sessiondata-domains sessx) dom-id)) act-id) statex)
)

;;; Return plans to go from the current states to within a set of regions.
;;; Tolerating more and more negative selectregions, as needed.
(defun sessiondata-get-plans (sessx to-regs) ; -> PlansCorrStore.
  (assert (sessiondata-p sessx))
  (assert (regionscorr-p to-regs))

  (let (plans)
    (setf plans (sessiondata-get-plans2 sessx (domainstore-all-current-regions (sessiondata-domains sessx)) to-regs))
    (if plans
      (return-from sessiondata-get-plans plans))
    (setf plans (sessiondata-get-plans2 sessx (domainstore-all-current-regions (sessiondata-domains sessx)) to-regs))
    (if plans
      (return-from sessiondata-get-plans plans))
    (setf plans (sessiondata-get-plans2 sessx (domainstore-all-current-regions (sessiondata-domains sessx)) to-regs))
    (if plans
      (return-from sessiondata-get-plans plans))
    plans
  )
)

;;; Return plans to go from a given set of regions to within another set of regions.
;;; Tolerating more and more negative selectregions, as needed.
(defun sessiondata-get-plans2 (sessx from-regs to-regs) ; -> PlansCorrStore.
  (assert (sessiondata-p sessx))
  (assert (regionscorr-p from-regs))
  (assert (regionscorr-p to-regs))
  (assert (not (regionscorr-intersects from-regs to-regs)))

  (let (from-rate to-rate min-rate le0-position plans path)

    ;; Find maximum rate possible by the least rate of the from and to regionscorr.
    (setf from-rate (selectregionsstore-rate (sessiondata-selectregions-store sessx) from-regs))
    (setf to-rate (selectregionsstore-rate (sessiondata-selectregions-store sessx) to-regs))
    (setf min-rate (min (rate-negative from-rate) (rate-negative to-rate)))

    ;; Find the rate position in the le0-levels list, and corresponding regionscorrstore-paths list.
    (setf le0-position (position min-rate (sessiondata-le0-levels sessx)))
    (if (null le0-position)
      (error "min-rate not found?"))

    ;; From the maximum le0 rate, on down, try finding a path.  
    (loop for inx from le0-position below (length (sessiondata-le0-levels sessx))
          while (null path) do

      (setf min-rate (nth inx (sessiondata-le0-levels sessx)))
      (setf path (regionscorrstore-find-path (nth inx (sessiondata-regionscorrstore-paths sessx)) from-regs to-regs))
    )

    (when (null path)
      (format t "~&sessiondata-get-plans2: No path found")
      (return-from sessiondata-get-plans2 nil)
    )

    ;(format t "~&sessiondata-get-plans2: Path found: ~A" (pathscorr-str path))

    ;(format t "~&TODO get plans")
    (setf plans (domainstore-get-plans (sessiondata-domains sessx) from-regs to-regs path))

    (if plans
      (progn
        (setf (planscorrstore-value plans) min-rate)
        ;(format t "~&sessiondata-get-plans2: Plans found: ~A" (planscorrstore-str plans))
      )
      ;(format t "~&sessiondata-get-plans2: No plans found")
    )

    plans
  )
)

;;; Return need to exit negative-rated selectregion, with plan, if needed.
(defun sessiondata-move-from-negative-selectregions (sessx) ; -> needstore.
  ;(format t "~&sessiondata-move-from-negative-selectregions")

  (assert (sessiondata-p sessx))

  (let ((needs (needstore-new nil)) cur-regs cur-rate close-rcs (min-dist 9999) dist plans nedx)

    (setf cur-regs (sessiondata-domain-current-regions sessx))
    (setf cur-rate (selectregionsstore-rate (sessiondata-selectregions-store sessx) cur-regs))

    (if (or (zerop (rate-negative cur-rate))  (= (rate-negative cur-rate) (car (sessiondata-le0-levels sessx))))
      (return-from sessiondata-move-from-negative-selectregions needs))

    ;; Collect closest regionstorecorrs from least negative in regionscorrstore-paths.
    (loop for rcsx in (regionscorrstore-regionscorrs (car (sessiondata-regionscorrstore-paths sessx))) do

      (setf dist (regionscorr-distance rcsx cur-regs))

      (when (< dist min-dist)
        (assert (plusp dist))
        (setf min-dist dist close-rcs nil)) 

      (if (= dist min-dist)
        (push rcsx close-rcs))
    )
   
    ;; Collect closest regionstorecorrs from least negative in regionscorrstore-paths.
    (loop for rcsx in (regionscorrstore-regionscorrs (car (sessiondata-regionscorrstore-paths sessx))) do

      (setf dist (regionscorr-distance rcsx cur-regs))

      (when (< dist min-dist)
        (assert (plusp dist))
        (setf min-dist dist close-rcs nil)) 

      (if (= dist min-dist)
        (push rcsx close-rcs))
    ) ; next rcsx

    ;; Generate needs.
    (loop for rcsx in close-rcs do
      (setf nedx (need-new :kind *change-position*
                           :reason *avoid-negative-selectregions*
                           :target rcsx
                           ))

      (setf plans (sessiondata-get-plans sessx rcsx))
      (if plans
         (setf (need-plan nedx) plans)
      )

      (needstore-push needs nedx)
    ) ; next rcsx
    needs
  )
)

;;; Return need to seek positive-rated selectregion, with plan, if needed.
(defun sessiondata-move-to-positive-selectregions (sessx) ; -> needstore.
  ;(format t "~&sessiondata-move-to-positive-selectregions")

  (assert (sessiondata-p sessx))

  (let ((needs (needstore-new nil)) cur-regs cur-rate pos-rcs plans nedx)

    (setf cur-regs (sessiondata-domain-current-regions sessx))
    (setf cur-rate (selectregionsstore-rate (sessiondata-selectregions-store sessx) cur-regs))

    (when (and (plusp (rate-positive cur-rate)) (< (sessiondata-num-cycles-at sessx) (rate-positive cur-rate)))
      (setf (sessiondata-num-cycles-at sessx) (1+ (sessiondata-num-cycles-at sessx)))
      (return-from sessiondata-move-to-positive-selectregions needs))

    ;; Collect selectregions that are positive, not superset current states. 
    (loop for selx in (selectregionsstore-selectregions (sessiondata-selectregions-fragments sessx)) do

      (if (not (regionscorr-superset-of :sup (selectregions-regionscorr selx) :sub cur-regs))
        (push (selectregions-regionscorr selx) pos-rcs))
    )
   
    ; Generate needs.
    (loop for rcsx in pos-rcs do
      (setf nedx (need-new :kind *change-position*
                           :reason *seek-positive-selectregions*
                           :target rcsx
                           ))

      (setf plans (sessiondata-get-plans sessx rcsx))
      (if plans
         (setf (need-plan nedx) plans)
      )

      (needstore-push needs nedx)
    ) ; next rcsx
    needs
  )
)

;;; Check and update previous-position and num-cycles-at.
(defun sessiondata-check-previous-position (sessx) ; -> side effect, sessiondata changed.
  (assert (sessiondata-p sessx))

  (let ((cur-states (sessiondata-domain-current-states sessx)))
    (if (statescorr-eq cur-states (sessiondata-previous-position sessx))
      (setf (sessiondata-num-cycles-at sessx) (1+ (sessiondata-num-cycles-at sessx)))
      (progn
        (setf (sessiondata-num-cycles-at sessx) 0)
        (setf (sessiondata-previous-position sessx) cur-states)
      )
    )
  )
)

